import pytest
from rdflib import Graph, Literal, Namespace, URIRef

from buildingmotif.dataclasses import Library, Template
from buildingmotif.model_builder import TemplateBuilderContext, TemplateWrapper
from buildingmotif.namespaces import BRICK, OWL, RDF, RDFS

BLDG = Namespace("urn:example/")


@pytest.fixture
def ctx(bm):
    """
    Provides a TemplateBuilderContext with templates loaded
    from tests/unit/fixtures/templates/
    """
    context = TemplateBuilderContext(BLDG)
    # This loads all .yml files from the directory into a single library object
    lib = Library.load(directory="tests/unit/fixtures/templates")
    context.add_templates_from_library(lib)
    return context


def test_context_creation_and_template_loading(ctx: TemplateBuilderContext):
    """
    Tests if templates are loaded into the context correctly.
    """
    assert "single-zone-vav-ahu" in ctx.templates
    assert "supply-fan" in ctx.templates
    assert "outside-air-damper" in ctx.templates
    assert "vav" in ctx.templates
    assert "temp-sensor" in ctx.templates
    assert "zone" in ctx.templates  # from smalloffice.yml
    assert "opt-vav" in ctx.templates  # from smalloffice.yml
    assert isinstance(ctx.templates["single-zone-vav-ahu"], Template)
    assert isinstance(ctx.templates["vav"], Template)


def test_getitem_valid_template(ctx: TemplateBuilderContext):
    """Tests that __getitem__ returns a TemplateWrapper for a valid template name."""
    wrapper = ctx["temp-sensor"]
    assert isinstance(wrapper, TemplateWrapper)
    assert wrapper.template == ctx.templates["temp-sensor"]


def test_getitem_invalid_template_raises_keyerror(ctx: TemplateBuilderContext):
    """Tests that __getitem__ raises KeyError for an invalid template name."""
    with pytest.raises(KeyError):
        _ = ctx["non-existent-template"]


def test_parameter_binding(ctx: TemplateBuilderContext):
    """Tests setting and getting parameters on a TemplateWrapper."""
    wrapper = ctx["temp-sensor"]
    # Test setting with a string (should be namespaced)
    wrapper["name"] = "my_sensor"
    assert wrapper.bindings["name"] == BLDG["my_sensor"]
    assert wrapper["name"] == BLDG["my_sensor"]

    # Test setting with a URIRef
    sensor_uri = URIRef("urn:custom/sensor1")
    wrapper["name"] = sensor_uri
    assert wrapper.bindings["name"] == sensor_uri
    assert wrapper["name"] == sensor_uri

    # Test getting an unbound parameter (should auto-generate)
    vav_wrapper = ctx["vav"]  # 'zone' is a parameter
    generated_zone_uri = vav_wrapper["zone"]
    assert isinstance(generated_zone_uri, URIRef)
    assert str(generated_zone_uri).startswith(str(BLDG))
    assert "zone" in str(generated_zone_uri)  # check it's based on param name
    assert vav_wrapper.bindings["zone"] == generated_zone_uri


def test_setitem_invalid_parameter_raises_keyerror(ctx: TemplateBuilderContext):
    """Tests that __setitem__ raises KeyError for an invalid parameter name."""
    wrapper = ctx["temp-sensor"]
    with pytest.raises(KeyError):
        wrapper["invalid_param"] = "value"


def test_call_method_for_parameter_binding(ctx: TemplateBuilderContext):
    """Tests using the __call__ method for binding parameters."""
    wrapper = ctx["temp-sensor"](name=BLDG["sensor_call"])
    assert wrapper["name"] == BLDG["sensor_call"]


def test_compile_simple_template_wrapper(ctx: TemplateBuilderContext):
    """Tests compiling a simple template wrapper without dependencies."""
    wrapper = ctx["temp-sensor"](name=BLDG["sensor1"])
    graph = wrapper.compile()

    assert isinstance(graph, Graph)
    assert (BLDG["sensor1"], RDF.type, BRICK.Temperature_Sensor) in graph


def test_compile_template_wrapper_with_dependencies(ctx: TemplateBuilderContext):
    """Tests compiling a template wrapper with dependencies."""
    ahu_name = BLDG["ahu1"]
    zone_name = BLDG["zone1"]
    wrapper = ctx["single-zone-vav-ahu"](name=ahu_name, zone=zone_name)
    # Other required params like oat, mat etc will be auto-generated by .fill()

    graph = wrapper.compile()
    assert (ahu_name, RDF.type, BRICK.AHU) in graph
    assert (ahu_name, BRICK.feeds, zone_name) in graph

    # Check for parts from dependencies (sf, oad)
    # Their names would be auto-generated based on ahu_name + param_name (e.g. ahu1_sf)
    # We need to find what they were bound to.
    sf_name = wrapper.bindings.get("sf")
    oad_name = wrapper.bindings.get("oad")

    assert sf_name is not None, "'sf' parameter should be bound"
    assert oad_name is not None, "'oad' parameter should be bound"

    assert (ahu_name, BRICK.hasPart, sf_name) in graph
    assert (sf_name, RDF.type, BRICK.Supply_Fan) in graph
    assert (ahu_name, BRICK.hasPart, oad_name) in graph
    assert (oad_name, RDF.type, BRICK.Outside_Air_Damper) in graph


def test_compile_template_handles_optional_parameters(ctx: TemplateBuilderContext):
    """Tests optional parameters are included if provided, omitted if not."""
    # 'outside-air-damper' has 'sen' as optional
    damper_name = BLDG["damper1"]
    # Case 1: Optional parameter not provided
    wrapper1 = ctx["outside-air-damper"](name=damper_name)
    graph1 = wrapper1.compile()
    assert (
        damper_name,
        BRICK.hasPoint,
        wrapper1.bindings["pos"],
    ) in graph1  # pos is required
    # Check 'sen' is not present by ensuring no Damper_Position_Sensor is linked to damper_name unless it was 'pos'
    sen_param_value_if_present = wrapper1.bindings.get("sen")
    if (
        sen_param_value_if_present
    ):  # if it got auto-created by fill (it shouldn't for optional)
        assert (damper_name, BRICK.hasPoint, sen_param_value_if_present) not in graph1

    # Case 2: Optional parameter provided
    sensor_pos_name = BLDG["damper1_sen"]
    wrapper2 = ctx["outside-air-damper"](name=damper_name, sen=sensor_pos_name)
    graph2 = wrapper2.compile()
    assert (damper_name, BRICK.hasPoint, sensor_pos_name) in graph2
    assert (sensor_pos_name, RDF.type, BRICK.Damper_Position_Sensor) in graph2


def test_context_compile_all_wrappers_and_direct_triples(ctx: TemplateBuilderContext):
    """Tests that context.compile() includes all wrappers and direct context triples."""
    sensor1_name = BLDG["sensor_ctx_1"]
    sensor2_name = BLDG["sensor_ctx_2"]
    ctx["temp-sensor"](name=sensor1_name)
    ctx["temp-sensor"](name=sensor2_name)

    # Add a triple directly to the context graph
    direct_triple_subject = BLDG["direct_entity"]
    ctx.add((direct_triple_subject, RDF.type, OWL.Class))

    full_graph = ctx.compile()

    assert (sensor1_name, RDF.type, BRICK.Temperature_Sensor) in full_graph
    assert (sensor2_name, RDF.type, BRICK.Temperature_Sensor) in full_graph
    assert (direct_triple_subject, RDF.type, OWL.Class) in full_graph


def test_context_compile_adds_rdfs_label(ctx: TemplateBuilderContext):
    """Tests that rdfs:label is added for typed resources during context compilation."""
    sensor_name = BLDG["labelled_sensor"]
    ctx["temp-sensor"](name=sensor_name)

    # Add a resource that already has a label
    prelabelled_entity = BLDG["prelabelled"]
    ctx.add((prelabelled_entity, RDF.type, BRICK.System))
    ctx.add((prelabelled_entity, RDFS.label, Literal("Existing Label")))

    full_graph = ctx.compile()

    # For sensor_name, type is BRICK.Temperature_Sensor
    # Expected label is the qname of BRICK.Temperature_Sensor
    _, _, class_qname = full_graph.namespace_manager.compute_qname(
        BRICK.Temperature_Sensor
    )
    assert (sensor_name, RDFS.label, Literal(class_qname)) in full_graph

    # For prelabelled_entity, existing label should be preserved
    assert (prelabelled_entity, RDFS.label, Literal("Existing Label")) in full_graph
    # Ensure no other label was added
    labels = list(full_graph.objects(prelabelled_entity, RDFS.label))
    assert len(labels) == 1


def test_variadic_parameter(ctx: TemplateBuilderContext):
    """Tests variadic parameter functionality."""
    wrapper = ctx["opt-vav"](name=BLDG["my_opt_vav"])  # 'opt-vav' from smalloffice.yml
    # 'occ' is an optional parameter in 'opt-vav'
    # P:name a brick:VAV ; brick:hasPoint P:occ .
    # P:occ a brick:Occupancy_Sensor ; brick:isPointOf P:zone .

    wrapper.to_variadic("occ")  # Make 'occ' variadic

    occ_sensor1_name = BLDG["occ_sensor_1"]
    occ_sensor2_name = BLDG["occ_sensor_2"]

    wrapper["occ"] = occ_sensor1_name  # Binds to occ0
    wrapper["occ"] = occ_sensor2_name  # Binds to occ1

    assert wrapper.bindings["occ0"] == occ_sensor1_name
    assert wrapper.bindings["occ1"] == occ_sensor2_name

    # Test retrieving all variadic values
    occ_values = wrapper["occ"]  # __getitem__ with variadic param name
    assert isinstance(occ_values, list)
    assert len(occ_values) == 2
    assert occ_sensor1_name in occ_values
    assert occ_sensor2_name in occ_values

    graph = wrapper.compile()

    # Check that both occupancy sensors are linked
    assert (BLDG["my_opt_vav"], BRICK.hasPoint, occ_sensor1_name) in graph
    assert (occ_sensor1_name, RDF.type, BRICK.Occupancy_Sensor) in graph
    assert (BLDG["my_opt_vav"], BRICK.hasPoint, occ_sensor2_name) in graph
    assert (occ_sensor2_name, RDF.type, BRICK.Occupancy_Sensor) in graph

    # Ensure 'zone' (another optional param) if not set, doesn't break things
    # and isn't spuriously created unless it's required by a variadic binding (not the case here)
    assert (
        occ_sensor1_name,
        BRICK.isPointOf,
        wrapper.bindings.get("zone0"),
    ) not in graph  # if zone was also variadic
    assert (
        occ_sensor1_name,
        BRICK.isPointOf,
        wrapper.bindings.get("zone"),
    ) not in graph  # if zone was not variadic and not set


def test_variadic_parameter_with_optional_related_parameter(
    ctx: TemplateBuilderContext,
):
    """
    Tests variadic parameters when a related parameter in the template body is optional.
    Uses 'opt-vav' which has optional 'occ' and 'zone'. 'occ' body includes '?occ brick:isPointOf ?zone'.
    """
    vav_name = BLDG["my_complex_vav"]
    wrapper = ctx["opt-vav"](name=vav_name)
    wrapper.to_variadic("occ")  # Make 'occ' variadic

    occ_sensor1_name = BLDG["complex_occ_1"]
    occ_sensor2_name = BLDG["complex_occ_2"]

    wrapper["occ"] = occ_sensor1_name  # Binds to occ0
    wrapper["occ"] = occ_sensor2_name  # Binds to occ1

    # Scenario 1: 'zone' (optional) is NOT set
    graph1 = wrapper.compile()

    # Check VAV and occ sensors exist and are typed
    assert (vav_name, RDF.type, BRICK.VAV) in graph1
    assert (vav_name, BRICK.hasPoint, occ_sensor1_name) in graph1
    assert (occ_sensor1_name, RDF.type, BRICK.Occupancy_Sensor) in graph1
    assert (vav_name, BRICK.hasPoint, occ_sensor2_name) in graph1
    assert (occ_sensor2_name, RDF.type, BRICK.Occupancy_Sensor) in graph1

    # Check that 'isPointOf ?zone' triples are NOT present for occ sensors,
    # as 'zone' was not provided and is optional.
    assert not list(graph1.triples((occ_sensor1_name, BRICK.isPointOf, None)))
    assert not list(graph1.triples((occ_sensor2_name, BRICK.isPointOf, None)))

    # Check that no HVAC_Zone is spuriously created
    assert not list(graph1.triples((None, RDF.type, BRICK.HVAC_Zone)))

    # Scenario 2: 'zone' (optional) IS set
    zone_name = BLDG["my_target_zone"]
    wrapper["zone"] = zone_name  # Now bind the optional 'zone'

    graph2 = wrapper.compile()

    # VAV and occ sensors should still be there
    assert (vav_name, RDF.type, BRICK.VAV) in graph2
    assert (vav_name, BRICK.hasPoint, occ_sensor1_name) in graph2
    assert (occ_sensor1_name, RDF.type, BRICK.Occupancy_Sensor) in graph2
    assert (vav_name, BRICK.hasPoint, occ_sensor2_name) in graph2
    assert (occ_sensor2_name, RDF.type, BRICK.Occupancy_Sensor) in graph2

    # Now, 'isPointOf zone_name' triples SHOULD be present for both occ sensors
    assert (occ_sensor1_name, BRICK.isPointOf, zone_name) in graph2
    assert (occ_sensor2_name, BRICK.isPointOf, zone_name) in graph2

    # check the zone itself is created and typed
    assert (zone_name, RDF.type, BRICK.HVAC_Zone) in graph2
