---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Model Correction with Templates

Specifically, our model is failing because the AHUs don't have the minimum number of supply fans associated with them. We *could* add thse fans explicitly by adding those triples to the model, but we can also
ask BuildingMOTIF to generate new templates that explicitly prompt us for the missing information.

```{code-cell}
# create a new library to hold these generated templates
generated_templates = Library.create("my-autogenerated-templates")
for diff in validation_result.diffset:
    diff.resolve(generated_templates)
```

We can take a closer look at the first autogenerated template:

```{code-cell}
for templ in generated_templates.get_templates():
    templ = templ.inline_dependencies()
    print(f"Name (autogenerated): {templ.name}")
    print(f"Parameters (autogenerated): {templ.parameters}")
    print("Template body (autogenerated):")
    print(templ.body.serialize())
    print('-' * 50)
    break # just to demonstrate the first piece of output
```

In this case, the generated templates are fairly simple. They require an input which is the name of the supply fan, but also the names of several missing points.

We can loop through each of these generated templates and create the names. Here, we are creating arbitrary names for the points but in a real setting you would
likely pull the equipment/point names from an external source like a BACnet network or BIM (see future tutorials for how to do this!)

Another challenge is the fact that we already have some supply fans in our model. Here, we can take advantage of the fact that the names of the fans in the existing
model are just the name of the AHU w/ the suffix `-Fan` added on the end. The name of the AHU is in the generated templates (see above) so we can just pull out the name
of the AHU, add the suffix, and use that as the value for the `name` parameter.



```{code-cell}
from buildingmotif.namespaces import BRICK
for templ in generated_templates.get_templates():
    templ = templ.inline_dependencies()
    # get name of AHU from template body
    ahu_name = next(templ.body.subjects(predicate=BRICK.hasPart))
    # generate the name of the supply fan
    supply_fan_name = ahu_name + '-Fan'

    # we know from our exploration above that each template has
    # 1 parameter called 'name', which we assign to the name of the supply fan
    bindings = {
        "name": supply_fan_name,
    }
    # the rest of the parameters have random names, so let's generate
    # random URIs for those by putting the name of the parameter at the end
    # of the fan's name
    for p in templ.parameters - {'name'}:
        print(p)
        bindings[p] = supply_fan_name + p
    supply_fan = templ.evaluate(bindings)
    model.add_graph(supply_fan)
    print(f"Added supply fan {supply_fan_name}")
```

### Validating our Model, Round 3

We use the same code as before to ask BuildingMOTIF if the model is now valid:

```{code-cell}
validation_result = model.validate(shape_collections)
print(f"Model is valid? {validation_result.valid}")
```

It is valid, so we are "done" with our model with respect to the manifest.
